#!/usr/bin/env bash
set -euo pipefail

PROGRAM_NAME="git-twin"

REPO_ROOT=""
MAIN_GIT_DIR=""
TWIN_GIT_DIR=""

print_usage() {
  cat <<'EOF'
Usage: git twin <command> [<args>...]

Utility for maintaining a twin Git repository inside .git/twin that tracks
files ignored by the main project repository.

Common commands:
  init             Initialise the twin repository in .git/twin.
  status           Show status of files tracked by the twin repository.
  add              Add files to the twin repository (forces inclusion of ignored files).
  commit           Commit staged changes to the twin repository.
  diff             Show changes recorded by the twin repository.
  log              View history stored in the twin repository.
  sync-ignore      Refresh ignore rules so the twin repo hides main repo files.
  help             Show this help text.

Any other subcommand is forwarded to Git running against the twin
repository. Examples: git twin remote add origin <url>, git twin push.
EOF
}

error() {
  printf '%s: %s\n' "$PROGRAM_NAME" "$1" >&2
}

die() {
  error "$1"
  exit 1
}

resolve_paths() {
  if [[ -n "$REPO_ROOT" ]]; then
    return
  fi

  if ! REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null); then
    die "not inside a Git repository"
  fi

  if ! MAIN_GIT_DIR=$(git rev-parse --git-dir 2>/dev/null); then
    die "unable to locate the .git directory"
  fi

  if [[ ! "$MAIN_GIT_DIR" = /* ]]; then
    MAIN_GIT_DIR="$REPO_ROOT/$MAIN_GIT_DIR"
  fi

  TWIN_GIT_DIR="$MAIN_GIT_DIR/twin"
}

ensure_not_bare_repo() {
  resolve_paths
  local is_bare
  if ! is_bare=$(git rev-parse --is-bare-repository 2>/dev/null); then
    die "failed to determine if repository is bare"
  fi
  if [[ "$is_bare" == "true" ]]; then
    die "git-twin requires a non-bare repository"
  fi
}

ensure_twin_exists() {
  resolve_paths
  if [[ ! -d "$TWIN_GIT_DIR" || ! -f "$TWIN_GIT_DIR/HEAD" ]]; then
    die "twin repository is not initialised. Run 'git twin init' first."
  fi
}

twin_git() {
  git --git-dir="$TWIN_GIT_DIR" --work-tree="$REPO_ROOT" "$@"
}

sync_core_config() {
  local key value
  for key in core.autocrlf core.eol core.filemode; do
    if value=$(git config --get "$key" 2>/dev/null); then
      twin_git config "$key" "$value"
    fi
  done
}

refresh_ignore_rules() {
  resolve_paths
  local exclude_dir="$TWIN_GIT_DIR/info"
  local exclude_file="$exclude_dir/exclude"
  mkdir -p "$exclude_dir"

  local tmp
  tmp=$(mktemp "$exclude_dir/exclude.XXXXXX")

  {
    printf '# Managed by git-twin. This file is regenerated automatically.\n'
    printf '# It lists files tracked by the main repository so they stay hidden from twin.\n'

    git -C "$REPO_ROOT" ls-files -z |
      while IFS= read -r -d '' path; do
        local entry
        entry="/$path"
        case "$path" in
          \#*|!*)
            entry="/\\$path"
            ;;
        esac
        printf '%s\n' "$entry"
      done
  } >"$tmp"

  mv "$tmp" "$exclude_file"
}

maybe_refresh_ignore_rules() {
  if [[ -d "$TWIN_GIT_DIR" ]]; then
    refresh_ignore_rules
  fi
}

prevent_branch_operations() {
  local subcommand="$1"
  case "$subcommand" in
    branch|checkout|switch)
      die "'$subcommand' is disabled for git-twin to keep a single twin branch"
      ;;
  esac
}

handle_init() {
  ensure_not_bare_repo
  resolve_paths

  if [[ -d "$TWIN_GIT_DIR" && -f "$TWIN_GIT_DIR/HEAD" ]]; then
    printf 'Twin repository already initialised at %s\n' "$TWIN_GIT_DIR"
    return
  fi

  if [[ -e "$TWIN_GIT_DIR" && ! -d "$TWIN_GIT_DIR" ]]; then
    die "cannot create twin repository at $TWIN_GIT_DIR (path exists)"
  fi

  mkdir -p "$TWIN_GIT_DIR"
  git init --bare "$TWIN_GIT_DIR" >/dev/null
  twin_git config core.worktree "$REPO_ROOT"
  twin_git config core.bare false
  twin_git symbolic-ref HEAD refs/heads/twin >/dev/null
  sync_core_config
  refresh_ignore_rules

  cat <<EOF
Twin repository initialised in $TWIN_GIT_DIR
Run 'git twin add <file>' to start tracking ignored files.
EOF
}

handle_sync_ignore() {
  ensure_twin_exists
  refresh_ignore_rules
  printf 'Updated %s/info/exclude with main repository tracked files.\n' "$TWIN_GIT_DIR"
}

handle_add() {
  ensure_twin_exists
  maybe_refresh_ignore_rules

  local force_allowed=1
  local arg
  for arg in "$@"; do
    case "$arg" in
      -f|--force|-i|--interactive|-p|--patch|-e|--edit)
        force_allowed=0
        break
        ;;
    esac
  done

  if [[ $force_allowed -eq 1 ]]; then
    set -- --force "$@"
  fi

  twin_git add "$@"
}

forward_command() {
  ensure_twin_exists
  maybe_refresh_ignore_rules
  local subcommand="$1"
  shift
  prevent_branch_operations "$subcommand"
  twin_git "$subcommand" "$@"
}

main() {
  if [[ $# -eq 0 ]]; then
    print_usage
    exit 0
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
    help|-h|--help)
      print_usage
      ;;
    init)
      handle_init
      ;;
    sync-ignore)
      handle_sync_ignore
      ;;
    add)
      handle_add "$@"
      ;;
    branch|checkout|switch)
      prevent_branch_operations "$subcommand"
      ;;
    *)
      if [[ "$subcommand" == --* ]]; then
        forward_command "$subcommand" "$@"
      else
        forward_command "$subcommand" "$@"
      fi
      ;;
  esac
}

main "$@"
