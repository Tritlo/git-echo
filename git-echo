#!/usr/bin/env bash
set -euo pipefail

PROGRAM_NAME="git-echo"

REPO_ROOT=""
MAIN_GIT_DIR=""
ECHO_GIT_DIR=""

GIT_ECHO_EXCLUDE_START="# >>> git-echo tracked files >>>"
GIT_ECHO_EXCLUDE_END="# <<< git-echo tracked files <<<"

print_usage() {
  cat <<'EOF'
Usage: git echo <command> [<args>...]

Utility for maintaining a echo Git repository inside .git/echo that tracks
files ignored by the main project repository.

Common commands:
  init             Initialise the echo repository in .git/echo.
  status           Show status of files tracked by the echo repository.
  add              Add files to the echo repository (forces inclusion of ignored files).
  commit           Commit staged changes to the echo repository.
  diff             Show changes recorded by the echo repository.
  log              View history stored in the echo repository.
  sync-ignore      Refresh ignore rules so the echo repo hides main repo files.
  help             Show this help text.

Any other subcommand is forwarded to Git running against the echo
repository. Examples: git echo remote add origin <url>, git echo push.
EOF
}

error() {
  printf '%s: %s\n' "$PROGRAM_NAME" "$1" >&2
}

die() {
  error "$1"
  exit 1
}

resolve_paths() {
  if [[ -n "$REPO_ROOT" ]]; then
    return
  fi

  if ! REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null); then
    die "not inside a Git repository"
  fi

  if ! MAIN_GIT_DIR=$(git rev-parse --git-dir 2>/dev/null); then
    die "unable to locate the .git directory"
  fi

  if [[ ! "$MAIN_GIT_DIR" = /* ]]; then
    MAIN_GIT_DIR="$REPO_ROOT/$MAIN_GIT_DIR"
  fi

  ECHO_GIT_DIR="$MAIN_GIT_DIR/echo"
}

ensure_not_bare_repo() {
  resolve_paths
  local is_bare
  if ! is_bare=$(git rev-parse --is-bare-repository 2>/dev/null); then
    die "failed to determine if repository is bare"
  fi
  if [[ "$is_bare" == "true" ]]; then
    die "git-echo requires a non-bare repository"
  fi
}

ensure_echo_exists() {
  resolve_paths
  if [[ ! -d "$ECHO_GIT_DIR" || ! -f "$ECHO_GIT_DIR/HEAD" ]]; then
    die "echo repository is not initialised. Run 'git echo init' first."
  fi
}

echo_git() {
  git --git-dir="$ECHO_GIT_DIR" --work-tree="$REPO_ROOT" "$@"
}

sync_repo_config() {
  # Keep behaviour consistent between the main and echo repositories by copying
  # key configuration, including the author identity to keep commits working in
  # environments without global Git configuration.
  local key value
  for key in core.autocrlf core.eol core.filemode user.name user.email; do
    if value=$(git config --get "$key" 2>/dev/null); then
      echo_git config "$key" "$value"
    fi
  done
}

refresh_ignore_rules() {
  resolve_paths
  local exclude_dir="$ECHO_GIT_DIR/info"
  local exclude_file="$exclude_dir/exclude"
  mkdir -p "$exclude_dir"

  local tmp
  tmp=$(mktemp "$exclude_dir/exclude.XXXXXX")

  {
    printf '# Managed by git-echo. This file is regenerated automatically.\n'
    printf '# It lists files tracked by the main repository so they stay hidden from echo.\n'

    git -C "$REPO_ROOT" ls-files -z |
      while IFS= read -r -d '' path; do
        local entry
        entry="/$path"
        case "$path" in
          \#*|!*)
            entry="/\\$path"
            ;;
        esac
        printf '%s\n' "$entry"
      done
  } >"$tmp"

  mv "$tmp" "$exclude_file"
}

maybe_refresh_ignore_rules() {
  if [[ -d "$ECHO_GIT_DIR" ]]; then
    sync_repo_config
    refresh_ignore_rules
    update_main_exclude_rules
  fi
}

should_manage_main_exclude() {
  local value
  if value=$(git config --type=bool --get git-echo.exclude-tracked 2>/dev/null); then
    [[ "$value" == "true" ]]
  else
    return 0
  fi
}

write_without_git_echo_block() {
  local src="$1"
  local dst="$2"
  if [[ -f "$src" ]]; then
    awk -v start="$GIT_ECHO_EXCLUDE_START" -v end="$GIT_ECHO_EXCLUDE_END" '
      $0 == start {skip=1; next}
      $0 == end && skip==1 {skip=0; next}
      !skip {print}
    ' "$src" >"$dst"
  else
    : >"$dst"
  fi
}

update_main_exclude_rules() {
  resolve_paths

  local manage=0
  if should_manage_main_exclude; then
    manage=1
  fi

  local exclude_dir="$MAIN_GIT_DIR/info"
  local exclude_file="$exclude_dir/exclude"

  if [[ $manage -eq 0 && ! -f "$exclude_file" ]]; then
    return
  fi

  mkdir -p "$exclude_dir"

  local tmp
  tmp=$(mktemp "$exclude_dir/exclude.git-echo.XXXXXX")

  write_without_git_echo_block "$exclude_file" "$tmp"

  if [[ $manage -eq 1 ]]; then
    if [[ -s "$tmp" && $(tail -c 1 "$tmp" 2>/dev/null) != $'\n' ]]; then
      printf '\n' >>"$tmp"
    fi

    {
      printf '%s\n' "$GIT_ECHO_EXCLUDE_START"
      printf '# Managed by git-echo. This section lists files tracked only by the echo repository.\n'
      echo_git ls-files -z |
        while IFS= read -r -d '' path; do
          local entry="/$path"
          case "$path" in
            \#*|!*)
              entry="/\\$path"
              ;;
          esac
          printf '%s\n' "$entry"
        done
      printf '%s\n' "$GIT_ECHO_EXCLUDE_END"
    } >>"$tmp"
  fi

  mv "$tmp" "$exclude_file"
}

prevent_branch_operations() {
  local subcommand="$1"
  case "$subcommand" in
    branch|checkout|switch)
      die "'$subcommand' is disabled for git-echo to keep a single echo branch"
      ;;
  esac
}

handle_init() {
  ensure_not_bare_repo
  resolve_paths

  if [[ -d "$ECHO_GIT_DIR" && -f "$ECHO_GIT_DIR/HEAD" ]]; then
    printf 'Echo repository already initialised at %s\n' "$ECHO_GIT_DIR"
    return
  fi

  if [[ -e "$ECHO_GIT_DIR" && ! -d "$ECHO_GIT_DIR" ]]; then
    die "cannot create echo repository at $ECHO_GIT_DIR (path exists)"
  fi

  mkdir -p "$ECHO_GIT_DIR"
  git init --bare --initial-branch=echo "$ECHO_GIT_DIR" >/dev/null
  echo_git config core.worktree "$REPO_ROOT"
  echo_git config core.bare false
  echo_git symbolic-ref HEAD refs/heads/echo >/dev/null
  sync_repo_config
  refresh_ignore_rules
  update_main_exclude_rules

  cat <<EOF
Echo repository initialised in $ECHO_GIT_DIR
Run 'git echo add <file>' to start tracking ignored files.
EOF
}

handle_sync_ignore() {
  ensure_echo_exists
  refresh_ignore_rules
  update_main_exclude_rules
  printf 'Updated %s/info/exclude with main repository tracked files.\n' "$ECHO_GIT_DIR"
}

handle_add() {
  ensure_echo_exists
  maybe_refresh_ignore_rules

  local force_allowed=1
  local arg
  for arg in "$@"; do
    case "$arg" in
      -f|--force|-i|--interactive|-p|--patch|-e|--edit)
        force_allowed=0
        break
        ;;
    esac
  done

  if [[ $force_allowed -eq 1 ]]; then
    set -- --force "$@"
  fi

  echo_git add "$@"
}

handle_commit() {
  ensure_echo_exists
  maybe_refresh_ignore_rules
  if echo_git commit "$@"; then
    update_main_exclude_rules
  else
    return $?
  fi
}

forward_command() {
  ensure_echo_exists
  maybe_refresh_ignore_rules
  local subcommand="$1"
  shift
  prevent_branch_operations "$subcommand"
  echo_git "$subcommand" "$@"
}

main() {
  if [[ $# -eq 0 ]]; then
    print_usage
    exit 0
  fi

  local subcommand="$1"
  shift

  case "$subcommand" in
    help|-h|--help)
      print_usage
      ;;
    init)
      handle_init
      ;;
    sync-ignore)
      handle_sync_ignore
      ;;
    add)
      handle_add "$@"
      ;;
    commit)
      handle_commit "$@"
      ;;
    branch|checkout|switch)
      prevent_branch_operations "$subcommand"
      ;;
    *)
      if [[ "$subcommand" == --* ]]; then
        forward_command "$subcommand" "$@"
      else
        forward_command "$subcommand" "$@"
      fi
      ;;
  esac
}

main "$@"
